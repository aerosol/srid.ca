---
date: 2020-06-20
---

# Handling HTTP errors in `req`

:::{.ui .warning .message}
### WIP
This is a work-in-progress note. Don't link to it just yet.
:::

The `req` package provides a `MonadHttp` class that has a [`handleHttpException`](https://hackage.haskell.org/package/req-3.2.0/docs/Network-HTTP-Req.html#v:handleHttpException) method.  

How do we handle HTTP client errors in `Either` monad instead?

## Define our own monad

We write our Monad by creating a type that wrapps the various monad transform typers, which gets us the appropriate monad instances for free.

```haskell
newtype GitHubT a = GitHubT
  { unMonadGitHub ::
      ReaderT GitHubTokenResponse (ExceptT GitHubApiError Req) a
  }
  deriving
    ( Applicative,
      Functor,
      Monad,
      MonadIO,
      MonadReader GitHubTokenResponse,
      MonadError GitHubApiError
    )

instance MonadHttp GitHubT where
  handleHttpException e =
    print e >> throwAppError e
    where
      throwAppError = \case
        VanillaHttpException err ->
          throwError $ GitHubApiError_HttpException $ show err
        JsonHttpException err ->
          throwError $ GitHubApiError_BadResponse err

runGitHub :: MonadIO m => GitHubTokenResponse -> GitHubT a -> m (Either GitHubApiError a)
runGitHub tok =
  liftIO
    . runReq defaultHttpConfig
    . runExceptT
    . usingReaderT tok
    . unMonadGitHub
```

We can then define domain-specific operations on this monad, such as to get the OAuth token as `req`'s `Option` type:

```haskell
authOption :: GitHubT (Option 'Https)
authOption =
  oAuth2Token . encodeUtf8 . _githubTokenResponse_accessToken <$> ask
```
